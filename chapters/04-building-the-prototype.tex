\chapter{Prototype}
\section{Goals}
  The prototype should allow the user to generate visualization in Vega-Lite for a given data . The generated visualizations should be based on preferences of the user and selections and actions what the user did. The prototype should respect that the user may does not know anything about Vega-Lite grammar and its JSON syntax.

  The prototype should has some graphical user interface (GUI) to make the selection of user prefered visualizations easier for the user and make the complete interaction with the prototype easier without any deep knowledge of command line. The GUI is almost required for this task, because the display of visualization and following selection would be much more complicated to realize by user's interaction with the command line.

  Also, the prototype should respect that the user may does not know anything about statistical datatypes and it should provide an automatical detection of feature datatypes in the given dataset.

  The prototype should use mechasims to prevent user fatique, such as heuristics that restrain size of searched state space of feasible solutions.

  Once the visualization is good enough for the user, the prototype should provide a way of retrieving the specifications of visualizations in Vega-Lite JSON syntax, so the user can actually use and share them.
\section{Vega-Lite}
  Vega-Lite is a high-level visualization grammar of interactive graphics, a declarative language for creating, saving and sharing visualizations. It is build on top of Vega visualization grammar to provides a concise JSON syntax for rapidly generating visualization to support data analysis \cite{vega}.

  A Vega-Lite specification describes a visualization as mappings from data to properties of graphical marks and this specification is defined in a JSON format\cite{vega}. The specification is parsed by Vega-Lite's JavaScript runtime compiler to automatically generate this specification into a lower-level, more detailed Vega \cite{vega-not-lite} specification that uses its compiler to render visualization components, such as axes, marks, legends and scale of the defined vizualization as a static image or as a web-based view. Thanks to carefully defined rules, Vega-Lite also automatically determines properties of these components to keep specifications succinct and expressive, but still provide user control.

  As Vega-Lite is designed for analysis, it supports data transformations such as aggregation, sorting, binning and visualization tranformations stacking and faceting. It also supports composion of visualizations to create layered and multi-view displays with an additional support of interactive selection.

  However, the implementation of the prototype does not support these layered multi-view composions, also complex transformations and selection of data. Interactive interfaces of the visualizations are not also supported to be generated by the prototype. The prototype applies evolutionary mechanisms on the mappings of data values to mark properties.

  In the following reading, there are described only parts of all features, properties and functions of Vega-Lite, that are minimally required for the understanding of the Vega-Lite, its syntax, structure and which parts of Vega-Lite are evolved in the prototype.

  \subsection{Common Properties of Specifications}
  All specifications in Vega-Lite can contain properties as \textbf{name} for later reference, \textbf{description} for comments, \textbf{title} of the vizualization, \textbf{data} as a data source, that can be loaded inline or from an external source and \textbf{transform} array of data transformation of the given data for calculating new fields and for filtering of given data. The prototype in this thesis does not actively work with any of these properties.

  \subsection{Top-level Specifications}
  All specification can contain these following top-level specifications. The prototype also does not actively work with these properties. The properties are \textbf{\$schema}, which is a source of Vega-Lite specification, \textbf{background} as CSS color property, \textbf{padding} from the edge of the visualization canvas to the data rectangle, \textbf{autosize}, that sets how the visualization size should be determined and \textbf{config}, which is Vega-Lite configuration object.

  \subsection{Single View Specification}

  \begin{listing}[htbp]
  \caption{\label{code:single-view-example}A structure of a single view specification in Vega-Lite \cite{vega-lite-single-view-specification}}
  \begin{minted}[bgcolor=codebg]{js}
{
  // Properties for top-level specification
  "$schema": "https://vega.github.io/schema/vega-lite/v3.json",
  "background": ...,
  "padding": ...,
  "autosize": ...,
  "config": ...,

  // Properties for any specifications
  "title": ...,
  "name": ...,
  "description": ...,
  "data": ...,
  "transform": ...,

  // Properties for any single view specifications
  "width": ...,
  "height": ...,
  "mark": ...,
  "encoding": {
    "x": {
      "field": ...,
      "type": ...,
      ...
    },
      "y": ...,
      "color": ...,
      ...
    }
}
\end{minted}
\end{listing}
  A single view specification describes a mark type of the visualization and encoding mapping between data features and properties of the mark. Once the mark type and the encoding is provided, Vega-Lite produces axes, legends and scales of the visualization that follows carefully defined rules. With these rules, Vega-Lite is also able to determine properties of these components and also give a negative feedback, if the specification is not valid and Vega-Lite has to change the specification \cite{vega-lite-single-view-specification}. The summarization of available properties for a single view specification are described in the table \ref{table:single-view-specifications}. An structural example of a single view specification is show in listing \ref{code:single-view-example}

  \begin{table}[htbp]
        \centering
        \caption{Description of properties for single view specification\cite{vega-lite-single-view-specification}}
        \label{table:single-view-specifications}
            \begin{tabular}{ m{8em} m{22em} }
            \toprule
                \textbf{Property} & \textbf{Description} \\
            \toprule

       mark                         & \textbf{Required}. A string describing the mark type (one of "bar", "circle", "square", "tick", "line", "area", "point", "rule", "geoshape", and "text") or a mark definition object. \\
\hline encoding    & A key-value mapping between encoding channels and definition of fields. \\
\hline width               & The width of a visualization. \\
\hline height           & The height of a visualization. \\
\hline view             & An object defining the view backgroundâ€™s fill and stroke. Not needed. \\
\hline selection     & A key-value mapping between selection names and definitions. \\
\hline projection    & An object defining properties of geographic projection, which will be applied to shape path for "geoshape" marks and to latitude and "longitude" channels for other marks. \\
\hline
            \end{tabular}
        \end{table}

\clearpage

\subsection{Encoding}
To encode a particular field from the dataset to the mark property, this mapping's definition must be provided by user and described in an \textbf{encoding} object.
The mapping of the field to the channel (like \textbf{x}, \textbf{y} or \textbf{color}) must contain \textbf{field} property and \textbf{type} property, which is data type of the field. In addition to top-level \textbf{transform} object, the Vega-Lite also supports inline tranforms of fields in a channel's definition.

From all the \textbf{encoding channels} shown in listing \ref{code:encoding-example}, the prototype allows to map and evolve fields to \textbf{x}, \textbf{y} channels and all \textbf{Mark Properties channels} (e.g., \textbf{color}, \textbf{fillOpacity}, \textbf{strokeOpacity}, \textbf{size} and \textbf{shape}). The other channels are not included in the process of evolution and in the prototype, because of their functionaly, that does not affect appearence of generated visualizations (Text, Tooltip, Hyperlink, Order, Level of Detail and Facet channels) or they would require much more provided information from the user before start of the evolutionary process. For example Geographic Position Channels require an image of a map and transformation of positions in data to project the rows in data on the map.
\begin{listing}[htbp]
\caption{\label{code:encoding-example}Structure of the encoding property for a single view specification \cite{vega-lite-encoding-single-view}}
\begin{minted}[bgcolor=codebg]{js}
// Specification of a Single View
{
  "data": ... ,
  "mark": ... ,
  "encoding": {     // Encoding
    // Position Channels
    "x": ...,
    "y": ...,
    "x2": ...,
    "y2": ...,

    // Geographic Position Channels
    "longtitude": ...,
    "latitude": ...,
    ...

    // Mark Properties Channels
    "color": ...,
    "opacity": ...,
    "fillOpacity": ...,
    "strokeOpacity": ...,
    "strokeWidth": ...,
    "size": ...,
    "shape": ...,

    // Text and Tooltip Channels
    "text": ...,
    "tooltip": ...,

    // Hyperlink Channel
    "href": ...,

    // Key Channel
    "key": ...,

    // Order Channel
    "order": ...,

    // Level of Detail Channel
    "detail": ...,

    // Facet Channels
    "facet": ...,
    "row": ...,
    "column": ...
  },
  ...
}
\end{minted}
\end{listing}

\begin{table}[htbp]
      \centering
      \caption{Supported field properties\cite{vega-lite-channel-definition}}
      \label{table:channel-definition}
          \begin{tabular}{ m{8em} m{22em} }
          \toprule
              \textbf{Property} & \textbf{Description} \\
          \toprule

     field                         & \textbf{Required}. A string defining the field from the dataset. \\
\hline type    & \textbf{Required} A data type of the encoded field (e.g., \textbf{quantitative}, \textbf{temporal}, \textbf{ordinal} and \textbf{nominal}).  \\
\hline bin               & A flag for binning of a \textbf{quantitative} field. It can be \textbf{true}, \textbf{false} or \textbf{BinParams} object. For the purpose of the prototype, only \textbf{true} and \textbf{false} are considered.  \\
\hline timeUnit           & Time unit for a \textbf{temporal} field. Because of not supporting \textbf{temporal} fields, this property is absolutely ignored in the prototype. \\
\hline aggregate             & Aggreation function for the field. Available values are: \textbf{mean}, \textbf{sum}, \textbf{median}, \textbf{min}, \textbf{max} and \textbf{count}.  \\
\hline title     & A title for a field. It is not very interesting for showing functionality of the prototype. Because of that, the default field title from dataset is used instead or the title corresponds with aggregate function over the values of the field. \\
\hline
          \end{tabular}
      \end{table}
\clearpage

\subsection{Encoding of a grammar}
To directly program all the rules, requires a lot of effort and the rules are then hard to read from the final program. This is the reason, why the all the possible specifications of visualizations and desribed by a grammar. The visualization specifications are generated by derivation of production rules included in the grammar. The program derivates these rules to generate the vizualization specifications. Additionaly, the grammar is easier to read and in a case of need, easier to control which specifications are produces by the program.

The JSON definition of the grammar contains properties described in table \ref{table:properties-of-grammar} with equivalents from the formal grammar. Used JSON constructs for definition of production rules are described in table \ref{table:production-rules-of-grammar}.
An example of JSON definition of the grammar and the actual grammar used in this prototype is shown in listing \ref{code:grammar-json-syntax}.
\begin{table}[htbp]
  \centering
  \caption{Properties of the JSON definitios of the grammar with analogy for formal grammars.}
  \label{table:properties-of-grammar}
      \begin{tabular}{ m{6em} m{13em} m{10em} }
      \toprule
          \textbf{Property} & \textbf{Description} & \textbf{In formal grammars} \\
      \toprule
\hline StartingSymbol & Evolutionary Algorithms always starts to generate the Vega-Lite specification from the production rule defined in \textbf{StartingSymbol} property. & A starting symbol. \\
\hline Expressions & A map of available production rules in the grammar. & A nonempty set of production rules. \\
\hline Terminals & A nonempty set that contains every element in the \textbf{Expressions} map. & A nonempty set of terminal symbols. \\
\hline Nonterminals & A nonempty set that contains every key in the \textbf{Expressions} map. & A nonempty set of nonterminal symbols. \\
\hline
    \end{tabular}
\end{table}

\begin{table}[htbp]
  \centering
  \caption{Equivalent constructs for the definition of production rules used in the JSON definition of the grammar used in the prototype.}
  \label{table:production-rules-of-grammar}
      \begin{tabular}{ m{9em} m{10em} m{9em} }
      \toprule
          \textbf{Construct} & \textbf{Description} & \textbf{In formal grammars} \\
      \toprule
\hline Key : [ Options[] ] & The key on the left side is a name of the production rule. The right hand side contains an array of Options[]. & The production rule. \\
\hline Options[ Elements[] ] & An array of element arrays (feasible values or keys). & A set strings that can be derived from the production rule. \\
\hline Elements[] & Array of element arrays (feasible values or keys). & A set of strings of terminals and nonterminals. \\
\hline element & A value or the production rule.  & Terminal or nonterminal symbol. \\
\hline [] & Empty element. & Empty string. \\
          \end{tabular}
      \end{table}

\begin{listing}[htbp]
\caption{\label{code:grammar-json-syntax}The grammar encoded into JSON syntax.}
\begin{minted}[bgcolor=codebg]{js}
{
  "Expressions": {
    "start": [ ["mark", "encoding"] ],
    "encoding": [
      ["fill", "opacity", "shape", "size", "color", "stroke"]
    ],
    "mark": [
      ["bar"],
      ["rect"],
      ["line"],
      ["point"],
      ["area"],
      ["circle"],
      ["square"]
    ],
    "color": [ ["aggregate", "bin", "field", "type"] ],
    "fill": [ ["aggregate", "bin", "field", "type"] ],
    "opacity": [ ["aggregate", "bin", "field", "type"] ],
    "shape": [ ["aggregate", "bin", "field", "type"] ],
    "size": [ ["aggregate", "bin", "field", "type"] ],
    "stroke": [ ["aggregate", "bin", "field", "type"] ],
    "x": [ ["aggregate", "bin", "field", "type"] ],
    "y": [ ["aggregate", "bin", "field", "type"] ],
    "aggregate": [
      ["mean"],
      ["sum"],
      ["median"],
      ["min"],
      ["max"],
      ["count"],
      ["average"],
      []
    ],
    "bin": [
      [true],
      []
    ],
    "field": [/* Names of fields in the dataset */],
    "type": [
      ["quantitative"],
      ["nominal"]
    ]
  },
  "StartingSymbol" : ["start"]
}
\end{minted}
\end{listing}

\clearpage

\section{Evolutionary algorithm}
I have chosen Genetic Programming to evolve the visualization's specification in this prototype, because of its tree representation. Genetic Programming also uses trees to represent individuals from the population. It does not mean, that other types of evolutionary algorithms cannot be used, but they would require an additional encoding of individuals's genotype to its phenotype, which means to translate the genotype to its visualization's specification.
  \subsection{Initialization}
  At first, the algorithm of Genetic Programming expands \textbf{StartingSymbol} from the JSON definition of the grammar. In the case of the implemented prototype and its grammar, it is \textbf{start} key. After this expansion, algorithms has only one option, that is expansion of the option \textbf{["mark", "encoding"]}. Both of these strings are production rules, because there exists production rules in the \textbf{Encodings} map. The important part is, that they are not nonterminals, they create an object accesible by the name of expanded element, then the algorithm continues with the expansion of elements accesible by the key in \textbf{Encodings} map. The expansion of a single branch of the tree ends, when the last expanded element is not a terminal. It means, that the element is not one of the keys in the \textbf{Encodings} map. In other words, it is not one of the production rules.

  Once the generation is done, algorithms removes all the empty strings. Empty strings are in the grammar, to represent, that the rule is only optional and during this process is removed from the individual, which is the final specification of the visualization.
  \subsection{Mutation}
  The individual's tree is traversed by the algorithm of mutation in preorder way. In each node of the tree, the algorithms randomly chooses, if the node's siblings should be replaced by a new subtree or not. If it is true, the new subtree is derivated from the production rule accesible by the node's name in \textbf{Encodings} map. This leads, that not every node from the tree is actually traversed by the algorithm. The nodes from the replaced subtree are no longer relevant for the individual, because they are no longer a part of the tree. The probability, that drives the mutation of nodes is set in GUI by the user.
  \subsection{Recombination}
  The recombination in Genetic Programming is defined as the crossover of arbitrary subtrees from two parents. However, I have decided, that the prototype exchanges only subtrees of field mappings. There are two reasons for that. The first reasons is, that properties of each mapping is dependant on data type of the field (e.g., binning of nominal values is not possible, also the most of the aggregate functions is not defined for nominal fields). The second reason is my decision based on my experience with the previous versions of the prototype. The previous versions of the prototype struggled to combine individuals selected by the user. Previously, the algorithm randomly selected the subtree of the individual and exchanged it with the second parent. For example, the user selected two specification. One of them is containing binning of some field and the second is containing the aggregation applied on another field. The algorithm exchanged them, but the user's preference is mapping of \textbf{x} and \textbf{y} field, so the binning is not the point of his interests.
  \subsection{Selection}
  All the individuals selected by the user are used for later breeding. The recombination happens only if two individuals were selected by the user. If user selected only one individual, only the mutation is applied on the individual in breeding process.
  \blindtext
\section{Heuristic approaches}
  To quicken the evolution and shrink the number of evolutionary steps, by restricting the seached space, the prototype uses four heuristic approaches.
  \subsection{Datatypes}
  The datatype of the field is marked as \textbf{nominal}, if any of the field's values is not numerical. If all the values are numerical, but the number of unique values is less then ten, the datatype of the field is also marked as \textbf{nominal}. Howerever, the user can still choose the proper datatypes in the GUI of the prototype. This approach removes the need of defining the \textbf{type} property in the mappings.
  \subsection{Number of mapping in a graph}
  The user can select, how many field should be mapped in the visualization's specification. This is based on a principle, that user probably know, which fields he wants to show in the visualization. This approach also removes all the specifications, that do not have an exact number of mappings to the selected fields.
  \subsection{Forbidden transformation of nominal features}
  As it was said before, the defined grammar does not cover every rule from Vega-Lite specification. On of them is, that \textbf{nominal} fields do not transformations, that are supported for \textbf{quantitative} fields. To avoid assigning these tranformations to \textbf{nominal} fields with the definition of the grammar, the algorithm that expands the rules would have to work with another type of production rules, that are translated differently, but it would complicate the implementation, the grammar and it is not needed for the prototype. Because of that, the prototype checks field mappings and removes the \textbf{aggregate} and the \textbf{bin} property, if the \textbf{type} property is nominal.
  \subsection{X and Y axes}
  The visualization's specification should primarily map fields to \textbf{x} and \textbf{y} axes instead of mapping them to mark properties. The algorithm prefers mapping to \textbf{x} and \textbf{y} axes and then, if there is any field left, the algorithm maps the rest of the fields to mark properties. This approach reduces the space search to visualization's specifications, that would not show only as a single mark.

  \section{Description of GUI}
  The GUI of the prototype consists from a left columns, where are most of the controls, and main window, where are visualizations shown.
    \subsection{Left Column Window}
    In the left column, user can control probability of change, projected in a next iteraction of the evolution. Then, there is a button to run the evolutionary algorithm on selected visualization from the main window. The user can also select one of predefined datasets and select columns from the datasets. Also, the user can define, what datatypes are the selected columns. After running the first iteration, these columns are locked and the evolutionary algorithm can use only the selected columns for the generation visuzalizations.

    \subsection{Main Window}
    The main window of the prototype is used for showing visualizations that can be selected by the user. The main window shows twelve visualizations in total. The user selects them by \textbf{Left Mouse Click}, which makes a border around the selected visualization turned green.
