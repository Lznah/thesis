\chapter{Implementation of prototype}
\section{Goals}
  The prototype should allow the user to generate visualization in Vega-Lite for a given data . The generated visualizations should be based on preferences of the user and selections and actions what the user did. The prototype should respect that the user may does not know anything about Vega-Lite grammar and its JSON syntax.

  The prototype should has some graphical user interface (GUI) to make the selection of user prefered visualizations easier for the user and make the complete interaction with the prototype easier without any deep knowledge of command line. The GUI is almost required for this task, because the display of visualization and following selection would be much more complicated to realize by user's interaction with the command line.

  Also, the prototype should respect that the user may does not know anything about statistical datatypes and it should provide an automatical detection of feature datatypes in the given dataset.

  The prototype should use mechasims to prevent user fatique, such as heuristics that restrain size of searched state space of feasible solutions.

  Once the visualization is good enough for the user, the prototype should provide a way of retrieving the specifications of visualizations in Vega-Lite JSON syntax, so the user can actually use and share them.


\section{Implemented EA}
I have chosen Genetic Programming, respectively Interactive Genetic Programming to evolve the visualization's specification in this prototype, because of its tree representation. Genetic Programming also uses trees to represent individuals from the population. It does not mean, that other types of evolutionary algorithms cannot be used, but they would require an additional encoding of individuals's genotype to its phenotype, which means to translate the genotype to its visualization's specification. Because of the relatively short grammar, I have decided that Grammatical Evolution would be an unnecessary complication. Also, Grammatical Evolution works with translation of the genotype to the phenotype, that would make heuristic approaches on the phenotype more complicated, because of backwards translation from the phenotype back to the genotype.
\subsection{Encoding of grammar}
To directly program all the rules, requires a lot of effort and the rules are then hard to read from the final program. This is the reason, why the all the possible specifications of visualizations and desribed by a grammar. The visualization specifications are generated by derivation of production rules included in the grammar. The program derivates these rules to generate the vizualization specifications. Additionaly, the grammar is easier to read and in a case of need, easier to control which specifications are produces by the program.

The JSON definition of the grammar contains properties described in table \ref{table:properties-of-grammar} with equivalents from the formal grammar. Used JSON constructs for definition of production rules are described in table \ref{table:production-rules-of-grammar}.
An example of JSON definition of the grammar and the actual grammar used in this prototype is shown in listing \ref{code:grammar-json-syntax}.
\begin{table}[htbp]
  \centering
  \caption{Properties of the JSON definitios of the grammar with analogy for formal grammars.}
  \label{table:properties-of-grammar}
      \begin{tabular}{ m{6em} m{13em} m{10em} }
      \hline
          \textbf{Property} & \textbf{Description} & \textbf{In formal grammars} \\
      \toprule
\hline StartingSymbol & Evolutionary Algorithms always starts to generate the Vega-Lite specification from the production rule defined in \textbf{StartingSymbol} property. & A starting symbol. \\
\hline Expressions & A map of available production rules in the grammar. & A nonempty set of production rules. \\
\hline Terminals & A nonempty set that contains every element in the \textbf{Expressions} map. & A nonempty set of terminal symbols. \\
\hline Nonterminals & A nonempty set that contains every key in the \textbf{Expressions} map. & A nonempty set of nonterminal symbols. \\
\hline
    \end{tabular}
\end{table}

\begin{table}[htbp]
  \centering
  \caption{Equivalent constructs for the definition of production rules used in the JSON definition of the grammar used in the prototype.}
  \label{table:production-rules-of-grammar}
      \begin{tabular}{ m{9em} m{10em} m{9em} }
      \hline
          \textbf{Construct} & \textbf{Description} & \textbf{In formal grammars} \\
      \toprule
\hline Key : [ Options[] ] & The key on the left side is a name of the production rule. The right hand side contains an array of Options[]. & The production rule. \\
\hline Options[ Elements[] ] & An array of element arrays (feasible values or keys). & A set strings that can be derived from the production rule. \\
\hline Elements[] & Array of element arrays (feasible values or keys). & A set of strings of terminals and nonterminals. \\
\hline element & A value or the production rule.  & Terminal or nonterminal symbol. \\
\hline [] & Empty element. & Null symbol. \\
          \end{tabular}
      \end{table}

\begin{listing}[htbp]
\caption{\label{code:grammar-json-syntax}The grammar encoded into JSON syntax.}
\begin{minted}[bgcolor=codebg]{js}
{
  "Expressions": {
    "start": [ ["mark", "encoding"] ],
    "encoding": [
      ["fill", "opacity", "shape", "size", "color", "stroke"]
    ],
    "mark": [
      ["bar"],
      ["rect"],
      ["line"],
      ["point"],
      ["area"],
      ["circle"],
      ["square"]
    ],
    "color": [ ["aggregate", "bin", "field", "type"] ],
    "fill": [ ["aggregate", "bin", "field", "type"] ],
    "opacity": [ ["aggregate", "bin", "field", "type"] ],
    "shape": [ ["aggregate", "bin", "field", "type"] ],
    "size": [ ["aggregate", "bin", "field", "type"] ],
    "stroke": [ ["aggregate", "bin", "field", "type"] ],
    "x": [ ["aggregate", "bin", "field", "type"] ],
    "y": [ ["aggregate", "bin", "field", "type"] ],
    "aggregate": [
      ["mean"],
      ["sum"],
      ["median"],
      ["min"],
      ["max"],
      ["count"],
      ["average"],
      []
    ],
    "bin": [
      [true],
      []
    ],
    "field": [/* Names of fields in the dataset */],
    "type": [
      ["quantitative"],
      ["nominal"]
    ]
  },
  "StartingSymbol" : ["start"]
}
\end{minted}
\end{listing}

\clearpage
  \subsection{Initialization}
  At first, the algorithm of Genetic Programming expands \textbf{StartingSymbol} from the JSON definition of the grammar. In the case of the implemented prototype and its grammar, it is \textbf{start} key. After this expansion, algorithms has only one option, that is expansion of the option \textbf{["mark", "encoding"]}. Both of these strings are production rules, because there exists production rules in the \textbf{Encodings} map. The important part is, that they are not nonterminals, they create an object accesible by the name of expanded element, then the algorithm continues with the expansion of elements accesible by the key in \textbf{Encodings} map. The expansion of a single branch of the tree ends, when the last expanded element is not a terminal. It means, that the element is not one of the keys in the \textbf{Encodings} map. In other words, it is not one of the production rules.

  Once the generation is done, algorithms removes all the empty strings. Empty strings are in the grammar, to represent, that the rule is only optional and during this process is removed from the individual, which is the final specification of the visualization.
  \subsection{Mutation}
  The individual's tree is traversed by the algorithm of mutation in preorder way. In each node of the tree, the algorithms randomly chooses, if the node's siblings should be replaced by a new subtree or not. If it is true, the new subtree is derivated from the production rule accesible by the node's name in \textbf{Encodings} map. This leads, that not every node from the tree is actually traversed by the algorithm. The nodes from the replaced subtree are no longer relevant for the individual, because they are no longer a part of the tree. The probability, that drives the mutation of nodes is set in GUI by the user.
  \subsection{Recombination}
  The recombination in Genetic Programming is defined as the crossover of arbitrary subtrees from two parents. However, I have decided, that the prototype exchanges only subtrees of field mappings. There are two reasons for that. The first reasons is, that properties of each mapping is dependant on data type of the field (e.g., binning of nominal values is not possible, also the most of the aggregate functions is not defined for nominal fields). The second reason is my decision based on my experience with the previous versions of the prototype. The previous versions of the prototype struggled to combine individuals selected by the user. Previously, the algorithm randomly selected the subtree of the individual and exchanged it with the second parent. For example, the user selected two specification. One of them is containing binning of some field and the second is containing the aggregation applied on another field. The algorithm exchanged them, but the user's preference is mapping of \textbf{x} and \textbf{y} field, so the binning is not the point of his interests.
  \subsection{Selection}
  All the individuals selected by the user are used for later breeding. The recombination happens only if two individuals were selected by the user. If user selected only one individual, only the mutation is applied on the individual in breeding process.



\section{Heuristic approaches}
  To quicken the evolution and shrink the number of evolutionary steps, by restricting the seached space, the prototype uses four heuristic approaches.
  \subsection{Datatypes}
  The datatype of the field is marked as \textbf{nominal}, if any of the field's values is not numerical. If all the values are numerical, but the number of unique values is less then ten, the datatype of the field is also marked as \textbf{nominal}. Howerever, the user can still choose the proper datatypes in the GUI of the prototype. This approach removes the need of defining the \textbf{type} property in the mappings.
  \subsection{Number of mapping in a graph}
  The user can select, how many field should be mapped in the visualization's specification. This is based on a principle, that user probably know, which fields he wants to show in the visualization. This approach also removes all the specifications, that do not have an exact number of mappings to the selected fields.
  \subsection{Forbidden transformation of nominal features}
  As it was said before, the defined grammar does not cover every rule from Vega-Lite specification. On of them is, that \textbf{nominal} fields do not transformations, that are supported for \textbf{quantitative} fields. To avoid assigning these tranformations to \textbf{nominal} fields with the definition of the grammar, the algorithm that expands the rules would have to work with another type of production rules, that are translated differently, but it would complicate the implementation, the grammar and it is not needed for the prototype. Because of that, the prototype checks field mappings and removes the \textbf{aggregate} and the \textbf{bin} property, if the \textbf{type} property is nominal.
  \subsection{X and Y axes}
  The visualization's specification should primarily map fields to \textbf{x} and \textbf{y} axes instead of mapping them to mark properties. The algorithm prefers mapping to \textbf{x} and \textbf{y} axes and then, if there is any field left, the algorithm maps the rest of the fields to mark properties. This approach reduces the space search to visualization's specifications, that would not show only as a single mark.

  \section{Description of GUI}
  The GUI of the prototype consists from a left columns, where are most of the controls, and main window, where are visualizations shown.
    \subsection{Left Column Window}
    In the left column, user can control probability of change, projected in a next iteraction of the evolution. Then, there is a button to run the evolutionary algorithm on selected visualization from the main window. The user can also select one of predefined datasets and select columns from the datasets. Also, the user can define, what datatypes are the selected columns. After running the first iteration, these columns are locked and the evolutionary algorithm can use only the selected columns for the generation visuzalizations.

    \subsection{Main Window}
    The main window of the prototype is used for showing visualizations that can be selected by the user. The main window shows twelve visualizations in total. The user selects them by \textbf{Left Mouse Click}, which makes a border around the selected visualization turned green.

    \begin{landscape}
      \imagefigurelarge{prototype.png}{Graphical User Interface of implemented prototype}
    \end{landscape}
